class DecisionMatrix {
    constructor() {
        this.options = [];
        this.criteria = [];
        this.ratings = {}; // { optionId: { criterionId: rating } }
        this.weights = {}; // { criterionId: weight }
        this.storageKey = 'decisionMatrix_data';
        this.progressState = {
            optionsComplete: false,
            criteriaComplete: false,
            ratingsComplete: false
        };
        this.init();
    }
    init() {
        this.setupEventListeners();
        this.loadFromURL();
        // If no data loaded from URL, try loading from localStorage
        if (this.options.length === 0 && this.criteria.length === 0) {
            this.loadFromLocalStorage();
        }
        // If still no data, add default items
        if (this.options.length === 0 && this.criteria.length === 0) {
            this.addOption('Option 1');
            this.addOption('Option 2');
            this.addCriterion('Criterion 1', 5);
            this.addCriterion('Criterion 2', 5);
        }
        this.render();
    }
    updateProgress() {
        // Check if options have valid names
        this.progressState.optionsComplete = this.options.length >= 2 && 
            this.options.every(opt => opt.name && opt.name.trim().length > 0);
        // Check if criteria have valid names and weights
        this.progressState.criteriaComplete = this.criteria.length >= 1 && 
            this.criteria.every(crit => crit.name && crit.name.trim().length > 0) &&
            this.criteria.every(crit => this.weights[crit.id] >= 1 && this.weights[crit.id] <= 10);
        // Check if all ratings are filled
        this.progressState.ratingsComplete = this.options.length > 0 && 
            this.criteria.length > 0 &&
            this.options.every(opt => 
                this.criteria.every(crit => 
                    this.ratings[opt.id] && 
                    this.ratings[opt.id][crit.id] >= 1 && 
                    this.ratings[opt.id][crit.id] <= 10
                )
            );
        this.renderProgressIndicator();
    }
    updateInputValidationState(inputElement, value, isValid) {
        inputElement.classList.remove('input-valid', 'input-incomplete', 'input-error');
        if (value === '' || value === null || value === undefined) {
            inputElement.classList.add('input-incomplete');
        } else if (isValid) {
            inputElement.classList.add('input-valid');
        } else {
            inputElement.classList.add('input-error');
        }
    }
    renderProgressIndicator() {
        let progressContainer = document.getElementById('progress-indicator');
        if (!progressContainer) {
            // Create progress indicator if it doesn't exist
            const setupSection = document.getElementById('setup');
            progressContainer = document.createElement('div');
            progressContainer.id = 'progress-indicator';
            progressContainer.className = 'progress-indicator';
            setupSection.parentNode.insertBefore(progressContainer, setupSection);
        }
        const steps = [
            { 
                id: 'options', 
                label: 'Add Options', 
                complete: this.progressState.optionsComplete,
                description: 'Add at least 2 options with names'
            },
            { 
                id: 'criteria', 
                label: 'Define Criteria', 
                complete: this.progressState.criteriaComplete,
                description: 'Add criteria with names and weights (1-10)'
            },
            { 
                id: 'ratings', 
                label: 'Rate Options', 
                complete: this.progressState.ratingsComplete,
                description: 'Rate each option for each criterion (1-10)'
            }
        ];
        const completedSteps = steps.filter(s => s.complete).length;
        const progressPercentage = (completedSteps / steps.length) * 100;
        let html = '<h2>üéØ Your Progress</h2>';
        html += '<div class="progress-bar-container">';
        html += `<div class="progress-bar" style="width: ${progressPercentage}%"></div>`;
        html += '</div>';
        html += `<p class="progress-text">${completedSteps} of ${steps.length} steps completed (${Math.round(progressPercentage)}%)</p>`;
        html += '<div class="progress-steps">';
        steps.forEach((step, index) => {
            const stepClass = step.complete ? 'step-complete' : 'step-incomplete';
            const icon = step.complete ? '‚úì' : (index === completedSteps ? '‚Üí' : (index + 1));
            html += `
                <div class="progress-step ${stepClass}">
                    <div class="step-icon">${icon}</div>
                    <div class="step-content">
                        <div class="step-label">${step.label}</div>
                        <div class="step-description">${step.description}</div>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        progressContainer.innerHTML = html;
    }
    setupEventListeners() {
        document.getElementById('add-option').addEventListener('click', () => {
            this.addOption();
            this.render();
            this.saveToURL();
        });
        document.getElementById('add-criterion').addEventListener('click', () => {
            this.addCriterion();
            this.render();
            this.saveToURL();
        });
        document.getElementById('calculate-btn').addEventListener('click', () => {
            this.calculateResults();
        });
        document.getElementById('reset-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to reset everything?')) {
                this.reset();
            }
        });
        document.getElementById('share-btn').addEventListener('click', () => {
            this.copyShareLink();
        });
        document.getElementById('save-local-btn').addEventListener('click', () => {
            this.saveToLocalStorage();
        });
        document.getElementById('load-local-btn').addEventListener('click', () => {
            this.loadFromLocalStorage();
        });
        document.getElementById('export-json-btn').addEventListener('click', () => {
            this.exportAsJSON();
        });
        document.getElementById('export-csv-btn').addEventListener('click', () => {
            this.exportAsCSV();
        });
        document.getElementById('export-text-btn').addEventListener('click', () => {
            this.exportAsText();
        });
        // Keyboard shortcuts
        this.setupKeyboardShortcuts();
    }
    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Only trigger shortcuts if not typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            // Ctrl/Cmd + Enter: Calculate results
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                this.calculateResults();
            }
            // Ctrl/Cmd + S: Save to browser
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                this.saveToLocalStorage();
            }
            // Ctrl/Cmd + L: Load from browser
            if ((e.ctrlKey || e.metaKey) && e.key === 'l') {
                e.preventDefault();
                this.loadFromLocalStorage();
            }
            // Ctrl/Cmd + K: Copy share link
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                this.copyShareLink();
            }
        });
    }
    generateId() {
        return 'id_' + Math.random().toString(36).substring(2, 11);
    }
    addOption(name = '') {
        const id = this.generateId();
        this.options.push({ id, name });
        this.ratings[id] = {};
    }
    removeOption(id) {
        this.options = this.options.filter(opt => opt.id !== id);
        delete this.ratings[id];
        this.render();
        this.saveToURL();
    }
    addCriterion(name = '', weight = 5) {
        const id = this.generateId();
        this.criteria.push({ id, name });
        this.weights[id] = weight;
        // Initialize ratings for this criterion
        this.options.forEach(option => {
            if (!this.ratings[option.id]) {
                this.ratings[option.id] = {};
            }
            this.ratings[option.id][id] = 5;
        });
    }
    removeCriterion(id) {
        this.criteria = this.criteria.filter(crit => crit.id !== id);
        delete this.weights[id];
        // Remove ratings for this criterion
        Object.keys(this.ratings).forEach(optionId => {
            delete this.ratings[optionId][id];
        });
        this.render();
        this.saveToURL();
    }
    updateOptionName(id, name) {
        const option = this.options.find(opt => opt.id === id);
        if (option) {
            option.name = name.trim();
            this.saveToURL();
            this.updateProgress();
        }
    }
    updateCriterionName(id, name) {
        const criterion = this.criteria.find(crit => crit.id === id);
        if (criterion) {
            criterion.name = name.trim();
            this.saveToURL();
            this.updateProgress();
        }
    }
    updateWeight(criterionId, weight) {
        // Handle empty string separately
        if (weight === '' || weight === null || weight === undefined) {
            return false;
        }
        const weightValue = parseFloat(weight);
        // Validate weight is between 1 and 10
        if (isNaN(weightValue) || weightValue < 1 || weightValue > 10) {
            return false;
        }
        this.weights[criterionId] = weightValue;
        this.saveToURL();
        this.updateProgress();
        return true;
    }
    updateRating(optionId, criterionId, rating) {
        // Handle empty string separately
        if (rating === '' || rating === null || rating === undefined) {
            return false;
        }
        const ratingValue = parseFloat(rating);
        // Validate rating is between 1 and 10
        if (isNaN(ratingValue) || ratingValue < 1 || ratingValue > 10) {
            return false;
        }
        if (!this.ratings[optionId]) {
            this.ratings[optionId] = {};
        }
        this.ratings[optionId][criterionId] = ratingValue;
        this.saveToURL();
        this.updateProgress();
        return true;
    }
    render() {
        this.renderOptions();
        this.renderCriteria();
        this.renderMatrix();
        this.updateProgress();
    }
    renderOptions() {
        const container = document.getElementById('options-container');
        container.innerHTML = '';
        this.options.forEach((option, index) => {
            const div = document.createElement('div');
            div.className = 'option-item';
            div.setAttribute('role', 'listitem');
            const isValid = option.name && option.name.trim().length > 0;
            const validationClass = isValid ? 'input-valid' : 'input-incomplete';
            div.innerHTML = `
                <input type="text" 
                       value="${option.name || ''}" 
                       placeholder="Option ${index + 1}"
                       class="${validationClass}"
                       data-option-id="${option.id}"
                       aria-label="Option ${index + 1} name"
                       aria-required="true"
                       required>
                <button class="btn-remove" data-remove-option="${option.id}" aria-label="Remove option ${index + 1}">√ó</button>
            `;
            container.appendChild(div);
            // Add event listeners
            const input = div.querySelector('input');
            input.addEventListener('input', (e) => {
                this.updateOptionName(option.id, e.target.value);
                // Update visual feedback
                const hasValue = e.target.value.trim().length > 0;
                e.target.classList.remove('input-valid', 'input-incomplete', 'input-error');
                e.target.classList.add(hasValue ? 'input-valid' : 'input-incomplete');
                // Update aria-invalid
                e.target.setAttribute('aria-invalid', !hasValue);
            });
            input.addEventListener('blur', (e) => {
                if (e.target.value.trim().length === 0) {
                    e.target.classList.remove('input-valid', 'input-incomplete');
                    e.target.classList.add('input-error');
                    e.target.setAttribute('aria-invalid', 'true');
                } else {
                    e.target.setAttribute('aria-invalid', 'false');
                }
            });
            const removeBtn = div.querySelector('button');
            removeBtn.addEventListener('click', () => {
                if (this.options.length > 1) {
                    this.removeOption(option.id);
                } else {
                    this.showToast('You need at least one option');
                }
            });
        });
    }
    renderCriteria() {
        const container = document.getElementById('criteria-container');
        container.innerHTML = '';
        this.criteria.forEach((criterion, index) => {
            const div = document.createElement('div');
            div.className = 'criterion-item';
            div.setAttribute('role', 'listitem');
            const isNameValid = criterion.name && criterion.name.trim().length > 0;
            const isWeightValid = this.weights[criterion.id] >= 1 && this.weights[criterion.id] <= 10;
            const nameValidationClass = isNameValid ? 'input-valid' : 'input-incomplete';
            const weightValidationClass = isWeightValid ? 'input-valid' : 'input-incomplete';
            div.innerHTML = `
                <input type="text" 
                       value="${criterion.name || ''}" 
                       placeholder="Criterion ${index + 1}"
                       class="${nameValidationClass}"
                       data-criterion-id="${criterion.id}"
                       aria-label="Criterion ${index + 1} name"
                       aria-required="true"
                       required>
                <span class="weight-label" id="weight-label-${criterion.id}">Weight:</span>
                <input type="number" 
                       min="1" 
                       max="10" 
                       value="${this.weights[criterion.id] || 5}"
                       class="${weightValidationClass}"
                       data-weight-id="${criterion.id}"
                       aria-label="Criterion ${index + 1} weight (1-10)"
                       aria-required="true"
                       title="Enter a weight between 1 and 10">
                <button class="btn-remove" data-remove-criterion="${criterion.id}" aria-label="Remove criterion ${index + 1}">√ó</button>
            `;
            container.appendChild(div);
            // Add event listeners
            const nameInput = div.querySelector('input[type="text"]');
            nameInput.addEventListener('input', (e) => {
                this.updateCriterionName(criterion.id, e.target.value);
                // Update visual feedback
                const hasValue = e.target.value.trim().length > 0;
                e.target.classList.remove('input-valid', 'input-incomplete', 'input-error');
                e.target.classList.add(hasValue ? 'input-valid' : 'input-incomplete');
                e.target.setAttribute('aria-invalid', !hasValue);
            });
            nameInput.addEventListener('blur', (e) => {
                if (e.target.value.trim().length === 0) {
                    e.target.classList.remove('input-valid', 'input-incomplete');
                    e.target.classList.add('input-error');
                    e.target.setAttribute('aria-invalid', 'true');
                } else {
                    e.target.setAttribute('aria-invalid', 'false');
                }
            });
            const weightInput = div.querySelector('input[type="number"]');
            weightInput.addEventListener('input', (e) => {
                const isValid = this.updateWeight(criterion.id, e.target.value);
                this.updateInputValidationState(e.target, e.target.value, isValid);
                e.target.setAttribute('aria-invalid', !isValid);
            });
            weightInput.addEventListener('blur', (e) => {
                const value = parseFloat(e.target.value);
                if (e.target.value && (isNaN(value) || value < 1 || value > 10)) {
                    e.target.classList.remove('input-valid', 'input-incomplete');
                    e.target.classList.add('input-error');
                    e.target.setAttribute('aria-invalid', 'true');
                    this.showToast('Weight must be between 1 and 10');
                } else {
                    e.target.setAttribute('aria-invalid', 'false');
                }
            });
            const removeBtn = div.querySelector('button');
            removeBtn.addEventListener('click', () => {
                if (this.criteria.length > 1) {
                    this.removeCriterion(criterion.id);
                } else {
                    this.showToast('You need at least one criterion');
                }
            });
        });
    }
    renderMatrix() {
        const table = document.getElementById('decision-matrix');
        const matrixSection = document.getElementById('matrix-section');
        if (this.options.length === 0 || this.criteria.length === 0) {
            matrixSection.classList.add('hidden');
            return;
        }
        matrixSection.classList.remove('hidden');
        let html = '<thead><tr><th scope="col">Options / Criteria</th>';
        // Header row with criteria
        this.criteria.forEach(criterion => {
            html += `<th scope="col">${criterion.name || 'Unnamed'}<br><small class="weight-label">(Weight: ${this.weights[criterion.id]})</small></th>`;
        });
        html += '</tr></thead><tbody>';
        // Data rows
        this.options.forEach(option => {
            html += `<tr><th scope="row"><strong>${option.name || 'Unnamed'}</strong></th>`;
            this.criteria.forEach(criterion => {
                const rating = this.ratings[option.id]?.[criterion.id] || 5;
                html += `<td>
                    <input type="number" 
                           min="1" 
                           max="10" 
                           value="${rating}"
                           data-option-id="${option.id}"
                           data-criterion-id="${criterion.id}"
                           aria-label="Rating for ${option.name || 'Unnamed'} on ${criterion.name || 'Unnamed'}"
                           aria-required="true"
                           title="Rate ${option.name || 'Unnamed'} for ${criterion.name || 'Unnamed'} (1-10)">
                </td>`;
            });
            html += '</tr>';
        });
        html += '</tbody>';
        table.innerHTML = html;
        // Add event listeners to rating inputs
        table.querySelectorAll('input[type="number"]').forEach(input => {
            input.addEventListener('input', (e) => {
                const optionId = e.target.dataset.optionId;
                const criterionId = e.target.dataset.criterionId;
                const isValid = this.updateRating(optionId, criterionId, e.target.value);
                this.updateInputValidationState(e.target, e.target.value, isValid);
                e.target.setAttribute('aria-invalid', !isValid);
            });
            input.addEventListener('blur', (e) => {
                const value = parseFloat(e.target.value);
                if (e.target.value && (isNaN(value) || value < 1 || value > 10)) {
                    e.target.classList.remove('input-valid', 'input-incomplete');
                    e.target.classList.add('input-error');
                    e.target.setAttribute('aria-invalid', 'true');
                    this.showToast('Rating must be between 1 and 10');
                } else {
                    e.target.setAttribute('aria-invalid', 'false');
                }
            });
        });
    }
    calculateResults() {
        if (this.options.length === 0 || this.criteria.length === 0) {
            this.showToast('Please add options and criteria first');
            return;
        }
        // Check if all options have names
        const invalidOptions = this.options.filter(opt => !opt.name || opt.name.trim().length === 0);
        if (invalidOptions.length > 0) {
            this.showToast('Please provide names for all options');
            return;
        }
        // Check if all criteria have names
        const invalidCriteria = this.criteria.filter(crit => !crit.name || crit.name.trim().length === 0);
        if (invalidCriteria.length > 0) {
            this.showToast('Please provide names for all criteria');
            return;
        }
        // Check if all weights are valid
        const invalidWeights = this.criteria.filter(crit => {
            const weight = this.weights[crit.id];
            return weight === undefined || weight === null || weight < 1 || weight > 10;
        });
        if (invalidWeights.length > 0) {
            this.showToast('Please set valid weights (1-10) for all criteria');
            return;
        }
        // Check if all ratings are filled
        let missingRatings = false;
        this.options.forEach(option => {
            this.criteria.forEach(criterion => {
                const rating = this.ratings[option.id]?.[criterion.id];
                if (!rating || rating < 1 || rating > 10) {
                    missingRatings = true;
                }
            });
        });
        if (missingRatings) {
            this.showToast('Please rate all options for all criteria (1-10)');
            return;
        }
        const results = [];
        this.options.forEach(option => {
            let totalScore = 0;
            let maxPossibleScore = 0;
            const breakdown = [];
            this.criteria.forEach(criterion => {
                const rating = this.ratings[option.id]?.[criterion.id] || 0;
                const weight = this.weights[criterion.id] || 0;
                const score = rating * weight;
                totalScore += score;
                maxPossibleScore += 10 * weight;
                breakdown.push({
                    criterion: criterion.name,
                    rating,
                    weight,
                    score
                });
            });
            results.push({
                name: option.name || 'Unnamed',
                totalScore,
                maxPossibleScore,
                percentage: maxPossibleScore > 0 ? (totalScore / maxPossibleScore * 100).toFixed(1) : 0,
                breakdown
            });
        });
        // Sort by total score descending
        results.sort((a, b) => b.totalScore - a.totalScore);
        this.renderResults(results);
        // Scroll to results
        document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
        // Show success message
        this.showToast('Results calculated successfully! üéâ');
    }
    renderResults(results) {
        const container = document.getElementById('results-container');
        const resultsSection = document.getElementById('results-section');
        if (results.length === 0) {
            resultsSection.classList.add('hidden');
            return;
        }
        resultsSection.classList.remove('hidden');
        let html = '';
        results.forEach((result, index) => {
            html += `
                <div class="result-item">
                    <div>
                        <div class="result-name">${result.name}</div>
                        <div class="result-details">${result.percentage}% of maximum possible score</div>
                    </div>
                    <div class="result-score">${result.totalScore.toFixed(1)}</div>
                </div>
            `;
        });
        container.innerHTML = html;
    }
    saveToURL() {
        const data = {
            options: this.options,
            criteria: this.criteria,
            ratings: this.ratings,
            weights: this.weights
        };
        const encoded = btoa(encodeURIComponent(JSON.stringify(data)));
        const url = new URL(window.location.href);
        url.hash = encoded;
        window.history.replaceState(null, '', url.toString());
    }
    loadFromURL() {
        const hash = window.location.hash.slice(1);
        if (!hash) {
            return;
        }
        try {
            const decoded = JSON.parse(decodeURIComponent(atob(hash)));
            if (decoded.options && Array.isArray(decoded.options)) {
                this.options = decoded.options;
            }
            if (decoded.criteria && Array.isArray(decoded.criteria)) {
                this.criteria = decoded.criteria;
            }
            if (decoded.ratings && typeof decoded.ratings === 'object') {
                this.ratings = decoded.ratings;
            }
            if (decoded.weights && typeof decoded.weights === 'object') {
                this.weights = decoded.weights;
            }
        } catch (error) {
            console.error('Failed to load data from URL:', error);
            this.showToast('Failed to load data from URL');
        }
    }
    saveToLocalStorage() {
        try {
            const data = {
                options: this.options,
                criteria: this.criteria,
                ratings: this.ratings,
                weights: this.weights
            };
            localStorage.setItem(this.storageKey, JSON.stringify(data));
            this.showToast('Matrix saved to browser storage!');
        } catch (error) {
            console.error('Failed to save to localStorage:', error);
            this.showToast('Failed to save to browser storage');
        }
    }
    loadFromLocalStorage() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (!stored) {
                this.showToast('No saved matrix found in browser storage');
                return;
            }
            const data = JSON.parse(stored);
            if (data.options && Array.isArray(data.options)) {
                this.options = data.options;
            }
            if (data.criteria && Array.isArray(data.criteria)) {
                this.criteria = data.criteria;
            }
            if (data.ratings && typeof data.ratings === 'object') {
                this.ratings = data.ratings;
            }
            if (data.weights && typeof data.weights === 'object') {
                this.weights = data.weights;
            }
            this.render();
            this.showToast('Matrix loaded from browser storage!');
        } catch (error) {
            console.error('Failed to load from localStorage:', error);
            this.showToast('Failed to load from browser storage');
        }
    }
    exportAsJSON() {
        const data = {
            options: this.options,
            criteria: this.criteria,
            ratings: this.ratings,
            weights: this.weights
        };
        const json = JSON.stringify(data, null, 2);
        this.downloadFile(json, 'decision-matrix.json', 'application/json');
        this.showToast('Matrix exported as JSON!');
    }
    validateMatrixData() {
        if (this.options.length === 0 || this.criteria.length === 0) {
            this.showToast('Please add options and criteria first');
            return false;
        }
        return true;
    }
    calculateScores() {
        const results = [];
        this.options.forEach(option => {
            let totalScore = 0;
            let maxPossibleScore = 0;
            this.criteria.forEach(criterion => {
                const rating = this.ratings[option.id]?.[criterion.id] || 0;
                const weight = this.weights[criterion.id] || 0;
                const score = rating * weight;
                totalScore += score;
                maxPossibleScore += 10 * weight;
            });
            const percentage = maxPossibleScore > 0 ? (totalScore / maxPossibleScore * 100).toFixed(1) : 0;
            results.push({
                option,
                name: option.name || 'Unnamed',
                totalScore,
                percentage
            });
        });
        return results;
    }
    exportAsCSV() {
        if (!this.validateMatrixData()) {
            return;
        }
        let csv = 'Option';
        // Header row with criteria
        this.criteria.forEach(criterion => {
            csv += `,${this.escapeCSV(criterion.name || 'Unnamed')} (Weight: ${this.weights[criterion.id]})`;
        });
        csv += ',Total Score,Percentage\n';
        // Calculate results
        const results = this.calculateScores();
        // Data rows
        results.forEach(({ option, totalScore, percentage }) => {
            csv += this.escapeCSV(option.name || 'Unnamed');
            this.criteria.forEach(criterion => {
                const rating = this.ratings[option.id]?.[criterion.id] || 0;
                csv += `,${rating}`;
            });
            csv += `,${totalScore.toFixed(1)},${percentage}%\n`;
        });
        this.downloadFile(csv, 'decision-matrix.csv', 'text/csv');
        this.showToast('Matrix exported as CSV!');
    }
    exportAsText() {
        if (!this.validateMatrixData()) {
            return;
        }
        let text = '=== DECISION MATRIX ===\n\n';
        // Criteria section
        text += 'CRITERIA:\n';
        this.criteria.forEach((criterion, index) => {
            text += `${index + 1}. ${criterion.name || 'Unnamed'} (Weight: ${this.weights[criterion.id]})\n`;
        });
        text += '\n';
        // Options section with ratings
        text += 'OPTIONS:\n';
        this.options.forEach((option, optIndex) => {
            text += `\n${optIndex + 1}. ${option.name || 'Unnamed'}\n`;
            this.criteria.forEach(criterion => {
                const rating = this.ratings[option.id]?.[criterion.id] || 0;
                text += `   - ${criterion.name || 'Unnamed'}: ${rating}/10\n`;
            });
        });
        // Calculate and add results
        text += '\n=== RESULTS ===\n\n';
        const results = this.calculateScores();
        // Sort by total score descending
        results.sort((a, b) => b.totalScore - a.totalScore);
        results.forEach((result, index) => {
            text += `${index + 1}. ${result.name}\n`;
            text += `   Score: ${result.totalScore.toFixed(1)} (${result.percentage}%)\n`;
        });
        this.downloadFile(text, 'decision-matrix.txt', 'text/plain');
        this.showToast('Matrix exported as plain text!');
    }
    escapeCSV(str) {
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return '"' + str.replace(/"/g, '""') + '"';
        }
        return str;
    }
    downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
    reset() {
        this.options = [];
        this.criteria = [];
        this.ratings = {};
        this.weights = {};
        // Add default items
        this.addOption('Option 1');
        this.addOption('Option 2');
        this.addCriterion('Criterion 1', 5);
        this.addCriterion('Criterion 2', 5);
        this.render();
        this.saveToURL();
        // Hide results
        document.getElementById('results-section').classList.add('hidden');
        this.showToast('Matrix reset successfully');
    }
    copyShareLink() {
        const url = window.location.href;
        // Check if clipboard API is available
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(url).then(() => {
                this.showToast('Share link copied to clipboard!');
            }).catch(() => {
                this.fallbackCopyToClipboard(url);
            });
        } else {
            this.fallbackCopyToClipboard(url);
        }
    }
    fallbackCopyToClipboard(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                this.showToast('Share link copied to clipboard!');
            } else {
                this.showToast('Failed to copy link. Please copy manually from the address bar.');
            }
        } catch (error) {
            this.showToast('Failed to copy link. Please copy manually from the address bar.');
        }
        document.body.removeChild(textArea);
    }
    showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    }
}
function initLazyLoading() {
    // Check if Intersection Observer is supported
    if ('IntersectionObserver' in window) {
        const lazyElements = document.querySelectorAll('img[data-src], iframe[data-src]');
        if (lazyElements.length === 0) {
            return; // No lazy-loading elements found
        }
        const lazyObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const element = entry.target;
                    // Set the actual src from data-src
                    if (element.dataset.src) {
                        element.src = element.dataset.src;
                        element.removeAttribute('data-src');
                    }
                    // Set srcset if it exists
                    if (element.dataset.srcset) {
                        element.srcset = element.dataset.srcset;
                        element.removeAttribute('data-srcset');
                    }
                    // Remove lazy class and add loaded class
                    element.classList.remove('lazy');
                    element.classList.add('loaded');
                    // Stop observing this element
                    observer.unobserve(element);
                }
            });
        }, {
            // Load elements slightly before they enter viewport
            rootMargin: '50px 0px',
            threshold: 0.01
        });
        // Observe all lazy elements
        lazyElements.forEach(element => {
            lazyObserver.observe(element);
        });
    } else {
        // Fallback for browsers without Intersection Observer support
        // Load all images immediately
        const lazyElements = document.querySelectorAll('img[data-src], iframe[data-src]');
        lazyElements.forEach(element => {
            if (element.dataset.src) {
                element.src = element.dataset.src;
                element.removeAttribute('data-src');
            }
            if (element.dataset.srcset) {
                element.srcset = element.dataset.srcset;
                element.removeAttribute('data-srcset');
            }
            element.classList.remove('lazy');
            element.classList.add('loaded');
        });
    }
}
function initMobileNav() {
    const navToggle = document.getElementById('nav-toggle');
    const navMenu = document.getElementById('nav-menu');
    const navLinks = document.querySelectorAll('.nav-link');
    if (!navToggle || !navMenu) {
        return; // Navigation elements not found
    }
    // Toggle menu when hamburger is clicked
    navToggle.addEventListener('click', () => {
        navToggle.classList.toggle('active');
        navMenu.classList.toggle('active');
        // Update aria-expanded for accessibility
        const isExpanded = navMenu.classList.contains('active');
        navToggle.setAttribute('aria-expanded', isExpanded.toString());
    });
    // Close menu when a link is clicked
    navLinks.forEach(link => {
        link.addEventListener('click', () => {
            navToggle.classList.remove('active');
            navMenu.classList.remove('active');
            navToggle.setAttribute('aria-expanded', 'false');
        });
    });
    // Close menu when clicking outside
    document.addEventListener('click', (event) => {
        // Check if menu is active first to avoid expensive DOM operations
        if (navMenu.classList.contains('active')) {
            const isClickInsideNav = navToggle.contains(event.target) || navMenu.contains(event.target);
            if (!isClickInsideNav) {
                navToggle.classList.remove('active');
                navMenu.classList.remove('active');
                navToggle.setAttribute('aria-expanded', 'false');
            }
        }
    });
    // Close menu on escape key
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && navMenu.classList.contains('active')) {
            navToggle.classList.remove('active');
            navMenu.classList.remove('active');
            navToggle.setAttribute('aria-expanded', 'false');
        }
    });
}
document.addEventListener('DOMContentLoaded', () => {
    new DecisionMatrix();
    // Initialize theme
    initTheme();
    // Initialize mobile navigation
    initMobileNav();
    // Initialize lazy-loading for any images or iframes
    // (currently none in the app, but ready for future use)
    initLazyLoading();
});
function initTheme() {
    const themeToggle = document.getElementById('theme-toggle');
    const themeIcon = document.getElementById('theme-icon');
    const htmlElement = document.documentElement;
    if (!themeToggle || !themeIcon) {
        return; // Theme elements not found
    }
    // Check for saved theme preference or default to 'light'
    const savedTheme = localStorage.getItem('theme') || 'light';
    htmlElement.setAttribute('data-theme', savedTheme);
    updateThemeIcon(savedTheme, themeIcon);
    // Update aria-pressed to reflect current state
    themeToggle.setAttribute('aria-pressed', savedTheme === 'dark' ? 'true' : 'false');
    // Theme toggle handler
    themeToggle.addEventListener('click', () => {
        const currentTheme = htmlElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        htmlElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        updateThemeIcon(newTheme, themeIcon);
        // Update aria-pressed
        themeToggle.setAttribute('aria-pressed', newTheme === 'dark' ? 'true' : 'false');
        // Update aria-label to reflect what will happen next
        themeToggle.setAttribute('aria-label', newTheme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode');
    });
}
function updateThemeIcon(theme, iconElement) {
    if (!iconElement) {
        return; // Icon element not found
    }
    iconElement.textContent = theme === 'light' ? 'üåô' : '‚òÄÔ∏è';
}
